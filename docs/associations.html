<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
     <meta http-equiv="content-type" content="text/html; charset=utf-8" />
     <title>DataMapper - Associations</title>
     <link rel="stylesheet" href="/datamapper-docs/css/site.css" type="text/css" media="screen, projection" />
     <link rel="stylesheet" href="/datamapper-docs/css/code.css" type="text/css" media="screen, projection" />
     <!--[if lt IE 7]> <link rel="stylesheet" href="/datamapper-docs/css/ie_hacks.css" type="text/css" media="screen, projection" /> <![endif]-->
     <link rel="Shortcut Icon" type="image/x-icon" href="/datamapper-docs/favicon.ico" />
  </head>

  <body id="home">

  <div style="width:100%;background:#d1ecf1;padding:15px;color:#0c5460;text-align:center;font-weight:bold;margin-bottom:20px;">
    This is a clone of the datamapper docs. Datamapper.org was taken down and redirected around Feb, 2020. I claim no ownership of any of this stuff.
  </div>

    <div id="content">

      <div id="header">
                <h1><a href="/datamapper-docs/">DataMapper</a></h1>

        <ul>
          <li><a href="/datamapper-docs/docs">Documentation</a></li>
          <li><a href="https://github.com/datamapper/dm-core/wiki">Wiki</a></li>
          <li><a href="/datamapper-docs/getting-started.html" id="getStarted">Get Started</a></li>
        </ul>

      </div>

   <h1 id="associations">Associations</h1>

<p>Associations are a way of declaring relationships between models, for example a
blog Post “has many” Comments, or a Post belongs to an Author. They add a series
of methods to your models which allow you to create relationships and retrieve
related models along with a few other useful features. Which records are related
to which are determined by their foreign keys.</p>

<p>The types of associations currently in DataMapper are:</p>

<table summary="Associations">
  <thead>
    <tr>
      <th>DataMapper Terminology</th>
      <th>ActiveRecord Terminology</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>has n</td>
      <td>has_many</td>
    </tr>
    <tr>
      <td>has 1</td>
      <td>has_one</td>
    </tr>
    <tr>
      <td>belongs_to</td>
      <td>belongs_to</td>
    </tr>
    <tr>
      <td>has n, :things, :through =&gt; Resource</td>
      <td>has_and_belongs_to_many</td>
    </tr>
    <tr>
      <td>has n, :things, :through =&gt; :model</td>
      <td>has_many :association, :through =&gt; Model</td>
    </tr>
  </tbody>
</table>

<h2 id="declaring-associations">Declaring Associations</h2>

<p>This is done via declarations inside your model class. The class name of the
related model is determined by the symbol you pass in. For illustration, we’ll
add an association of each type. Pay attention to the pluralization or the
related model’s name.</p>

<h3 id="has-n-and-belongs_to-or-one-to-many">has n and belongs_to (or One-To-Many)</h3>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Post</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:comments</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span>     <span class="no">Serial</span>
  <span class="n">property</span> <span class="ss">:rating</span><span class="p">,</span> <span class="no">Integer</span>

  <span class="n">belongs_to</span> <span class="ss">:post</span>  <span class="c1"># defaults to :required =&gt; true</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">popular</span>
    <span class="n">all</span><span class="p">(</span><span class="ss">:rating</span><span class="p">.</span><span class="nf">gt</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">belongs_to</code> method accepts a few options. As we already saw in the example
above, <code class="highlighter-rouge">belongs_to</code> relationships will be required by default (the parent resource
must exist in order for the child to be valid). You can make the parent resource
optional by passing <code class="highlighter-rouge">:required =&gt; false</code> as an option to <code class="highlighter-rouge">belongs_to</code>.</p>

<p>If the relationship makes up (part of) the key of a model, you can tell DM to
include it as part of the primary key by adding the <code class="highlighter-rouge">:key =&gt; true</code> option.</p>

<h3 id="has-n-through-or-one-to-many-through">has n, :through (or One-To-Many-Through)</h3>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Photo</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:taggings</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:tags</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:taggings</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:taggings</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:photos</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:taggings</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tagging</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">belongs_to</span> <span class="ss">:tag</span><span class="p">,</span>   <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="n">belongs_to</span> <span class="ss">:photo</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note that some options that you might wish to add to an association have to be added to a property instead. For instance, if you wanted your association to be part of a unique index rather than the key, you might do something like this.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Tagging</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>
  
  <span class="n">property</span> <span class="ss">:tag_id</span><span class="p">,</span>          <span class="ss">:unique_index</span> <span class="o">=&gt;</span> <span class="ss">:uniqueness</span><span class="p">,</span> <span class="ss">:required</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="n">property</span> <span class="ss">:tagged_photo_id</span><span class="p">,</span> <span class="ss">:unique_index</span> <span class="o">=&gt;</span> <span class="ss">:uniqueness</span><span class="p">,</span> <span class="ss">:required</span> <span class="o">=&gt;</span> <span class="kp">true</span>

  <span class="n">belongs_to</span> <span class="ss">:tag</span>
  <span class="n">belongs_to</span> <span class="ss">:tagged_photo</span><span class="p">,</span> <span class="s1">'Photo'</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="has-and-belongs-to-many-or-many-to-many">Has, and belongs to, many (Or Many-To-Many)</h3>

<p>The use of Resource in place of a class name tells DataMapper to use an
anonymous resource to link the two models up.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="c1"># When auto_migrate! is being called, the following model</span>
<span class="c1"># definitions will create an</span>
<span class="c1">#</span>
<span class="c1">#  ArticleCategory</span>
<span class="c1">#</span>
<span class="c1"># model that will be automigrated and that will act as the join</span>
<span class="c1"># model. DataMapper just picks both model names, sorts them</span>
<span class="c1"># alphabetically and then joins them together. The resulting</span>
<span class="c1"># storage name follows the same conventions it would if the</span>
<span class="c1"># model had been declared traditionally.</span>
<span class="c1">#</span>
<span class="c1"># The resulting model is no different from any traditionally</span>
<span class="c1"># declared model. It contains two belongs_to relationships</span>
<span class="c1"># pointing to both Article and Category, and both underlying</span>
<span class="c1"># child key properties form the composite primary key (CPK)</span>
<span class="c1"># of that model. DataMapper uses consistent naming conventions</span>
<span class="c1"># to infer the names of the child key properties. Since it's</span>
<span class="c1"># told to link together an Article and a Category model, it'll</span>
<span class="c1"># establish the following relationships in the join model.</span>
<span class="c1">#</span>
<span class="c1">#  ArticleCategory.belongs_to :article,  'Article',  :key =&gt; true</span>
<span class="c1">#  ArticleCategory.belongs_to :category, 'Category', :key =&gt; true</span>
<span class="c1">#</span>
<span class="c1"># Since every many to many relationship needs a one to many</span>
<span class="c1"># relationship to "go through", these also get set up for us.</span>
<span class="c1">#</span>
<span class="c1">#  Article.has n, :article_categories</span>
<span class="c1">#  Category.has n, article_categories</span>
<span class="c1">#</span>
<span class="c1"># Essentially, you can think of ":through =&gt; Resource" being</span>
<span class="c1"># replaced with ":through =&gt; :article_categories" when DM</span>
<span class="c1"># processes the relationship definition.</span>
<span class="c1">#</span>
<span class="c1"># This also means that you can access the join model just like</span>
<span class="c1"># any other DataMapper model since there's really no difference</span>
<span class="c1"># at all. All you need to know is the inferred name, then you can</span>
<span class="c1"># treat it just like any other DataMapper model.</span>

<span class="k">class</span> <span class="nc">Article</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:categories</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="no">Resource</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Category</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:articles</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="no">Resource</span>
<span class="k">end</span>

<span class="c1"># create two resources</span>
<span class="n">article</span>  <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">create</span>
<span class="n">category</span> <span class="o">=</span> <span class="no">Category</span><span class="p">.</span><span class="nf">create</span>

<span class="c1"># link them by adding to the relationship</span>
<span class="n">article</span><span class="p">.</span><span class="nf">categories</span> <span class="o">&lt;&lt;</span> <span class="n">category</span>
<span class="n">article</span><span class="p">.</span><span class="nf">save</span>

<span class="c1"># link them by creating the join resource directly</span>
<span class="no">ArticleCategory</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:article</span> <span class="o">=&gt;</span> <span class="n">article</span><span class="p">,</span> <span class="ss">:category</span> <span class="o">=&gt;</span> <span class="n">category</span><span class="p">)</span>

<span class="c1"># unlink them by destroying the related join resource</span>
<span class="n">link</span> <span class="o">=</span> <span class="n">article</span><span class="p">.</span><span class="nf">article_categories</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="ss">:category</span> <span class="o">=&gt;</span> <span class="n">category</span><span class="p">)</span>
<span class="n">link</span><span class="p">.</span><span class="nf">destroy</span>

<span class="c1"># unlink them by destroying the join resource directly</span>
<span class="n">link</span> <span class="o">=</span> <span class="no">ArticleCategory</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">article</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="n">category</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
<span class="n">link</span><span class="p">.</span><span class="nf">destroy</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="self-referential-many-to-many-relationships">Self referential many to many relationships</h2>

<p>Sometimes you need to establish self referential relationships where both sides of the
relationship are of the same model. The canonical example seems to be the declaration of
a <em>Friendship</em> relationship between two people. Here’s how you would do that with DataMapper.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span>    <span class="no">Serial</span>
  <span class="n">property</span> <span class="ss">:name</span> <span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">:required</span> <span class="o">=&gt;</span> <span class="kp">true</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:friendships</span><span class="p">,</span> <span class="ss">:child_key</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:source_id</span> <span class="p">]</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:friends</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:friendships</span><span class="p">,</span> <span class="ss">:via</span> <span class="o">=&gt;</span> <span class="ss">:target</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Friendship</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">belongs_to</span> <span class="ss">:source</span><span class="p">,</span> <span class="s1">'Person'</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="n">belongs_to</span> <span class="ss">:target</span><span class="p">,</span> <span class="s1">'Person'</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="highlighter-rouge">Person</code> and <code class="highlighter-rouge">Friendship</code> model definitions look pretty straightforward at a first glance.
Every <code class="highlighter-rouge">Person</code> has an <em>id</em> and a <em>name</em>, and a <code class="highlighter-rouge">Friendship</code> points to two instances of <code class="highlighter-rouge">Person</code>.</p>

<p>The interesting part are the relationship definitions in the <code class="highlighter-rouge">Person</code> model. Since we’re modelling
friendships, we want to be able to get at one person’s friends with one single method call. First,
we need to establish a <em>one to many</em> relationship to the <code class="highlighter-rouge">Friendship</code> model.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Person</span>

  <span class="c1"># ...</span>

  <span class="c1"># Since the foreign key pointing to Person isn't named 'person_id',</span>
  <span class="c1"># we need to override it by specifying the :child_key option. If the</span>
  <span class="c1"># Person model's key would be something different from 'id', we would</span>
  <span class="c1"># also need to specify the :parent_key option.</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:friendships</span><span class="p">,</span> <span class="ss">:child_key</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:source_id</span> <span class="p">]</span>

<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This only gets us half the way though. We can now reach associated <code class="highlighter-rouge">Friendship</code> instances by traversing
<code class="highlighter-rouge">person.friendships</code>. However, we want to get at the actual <em>friends</em>, the instances of <code class="highlighter-rouge">Person</code>. We already
know that we can <em>go through</em> other relationships in order to be able to construct <em>many to many</em> relationships.</p>

<p>So what we need to do is to <em>go through</em> the friendship relationship to get at the actual friends. To
achieve that, we have to tweak various options of that <em>many to many</em> relationship definition.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Person</span>

  <span class="c1"># ...</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:friendships</span><span class="p">,</span> <span class="ss">:child_key</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:source_id</span> <span class="p">]</span>

  <span class="c1"># We name the relationship :friends cause that's the original intention</span>
  <span class="c1">#</span>
  <span class="c1"># The target model of this relationship will be the Person model as well,</span>
  <span class="c1"># so we can just pass self where DataMapper expects the target model</span>
  <span class="c1"># You can also use Person or 'Person' in place of self here. If you're</span>
  <span class="c1"># constructing the options programmatically, you might even want to pass</span>
  <span class="c1"># the target model using the :model option instead of the 3rd parameter.</span>
  <span class="c1">#</span>
  <span class="c1"># We "go through" the :friendship relationship in order to get at the actual</span>
  <span class="c1"># friends. Since we named our relationship :friends, DataMapper assumes</span>
  <span class="c1"># that the Friendship model contains a :friend relationship. Since this</span>
  <span class="c1"># is not the case in our example, because we've named the relationship</span>
  <span class="c1"># pointing to the actual friend person :target, we have to tell DataMapper</span>
  <span class="c1"># to use that relationship instead, when looking for the relationship to</span>
  <span class="c1"># piggy back on. We do so by passing the :via option with our :target</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:friends</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:friendships</span><span class="p">,</span> <span class="ss">:via</span> <span class="o">=&gt;</span> <span class="ss">:target</span>

<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Another example of a self referential relationship would be the
representation of a relationship where people can follow other people.
In this situation, any person can follow any number of other people.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Person</span>

  <span class="k">class</span> <span class="nc">Link</span>

    <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

    <span class="n">storage_names</span><span class="p">[</span><span class="ss">:default</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'people_links'</span>

    <span class="c1"># the person who is following someone</span>
    <span class="n">belongs_to</span> <span class="ss">:follower</span><span class="p">,</span> <span class="s1">'Person'</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>

    <span class="c1"># the person who is followed by someone</span>
    <span class="n">belongs_to</span> <span class="ss">:followed</span><span class="p">,</span> <span class="s1">'Person'</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>

  <span class="k">end</span>

  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span>   <span class="no">Serial</span>
  <span class="n">property</span> <span class="ss">:name</span><span class="p">,</span> <span class="no">String</span><span class="p">,</span> <span class="ss">:required</span> <span class="o">=&gt;</span> <span class="kp">true</span>


  <span class="c1"># If we want to know all the people that John follows, we need to look</span>
  <span class="c1"># at every 'Link' where John is a :follower. Knowing these, we know all</span>
  <span class="c1"># the people that are :followed by John.</span>
  <span class="c1">#</span>
  <span class="c1"># If we want to know all the people that follow Jane, we need to look</span>
  <span class="c1"># at every 'Link' where Jane is :followed. Knowing these, we know all</span>
  <span class="c1"># the people that are a :follower of Jane.</span>
  <span class="c1">#</span>
  <span class="c1"># This means that we need to establish two different relationships to</span>
  <span class="c1"># the 'Link' model. One where the person's role is :follower and one</span>
  <span class="c1"># where the person's role is to be :followed by someone.</span>

  <span class="c1"># In this relationship, the person is the follower</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:links_to_followed_people</span><span class="p">,</span> <span class="s1">'Person::Link'</span><span class="p">,</span> <span class="ss">:child_key</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:follower_id</span><span class="p">]</span>

  <span class="c1"># In this relationship, the person is the one followed by someone</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:links_to_followers</span><span class="p">,</span> <span class="s1">'Person::Link'</span><span class="p">,</span> <span class="ss">:child_key</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:followed_id</span><span class="p">]</span>


  <span class="c1"># We can then use these two relationships to relate any person to</span>
  <span class="c1"># either the people followed by the person, or to the people this</span>
  <span class="c1"># person follows.</span>

  <span class="c1"># Every 'Link' where John is a :follower points to a person that</span>
  <span class="c1"># is followed by John.</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:followed_people</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span>
    <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:links_to_followed_people</span><span class="p">,</span> <span class="c1"># The person is a follower</span>
    <span class="ss">:via</span>     <span class="o">=&gt;</span> <span class="ss">:followed</span>

  <span class="c1"># Every 'Link' where Jane is :followed points to a person that</span>
  <span class="c1"># is one of Jane's followers.</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:followers</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span>
    <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:links_to_followers</span><span class="p">,</span> <span class="c1"># The person is followed by someone</span>
    <span class="ss">:via</span>     <span class="o">=&gt;</span> <span class="ss">:follower</span>

  <span class="c1"># Follow one or more other people</span>
  <span class="k">def</span> <span class="nf">follow</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>
    <span class="n">followed_people</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="no">Array</span><span class="p">(</span><span class="n">others</span><span class="p">))</span>
    <span class="n">save</span>
    <span class="nb">self</span>
  <span class="k">end</span>

  <span class="c1"># Unfollow one or more other people</span>
  <span class="k">def</span> <span class="nf">unfollow</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>
    <span class="n">links_to_followed_people</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="ss">:followed</span> <span class="o">=&gt;</span> <span class="no">Array</span><span class="p">(</span><span class="n">others</span><span class="p">)).</span><span class="nf">destroy!</span>
    <span class="n">reload</span>
    <span class="nb">self</span>
  <span class="k">end</span>

<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="adding-to-associations">Adding To Associations</h2>

<p>Adding resources to <em>many to one</em> or <em>one to one</em> relationships is as simple as
assigning them to their respective writer methods. The following example shows how
to assign a target resource to both a <em>many to one</em> and a <em>one to one</em> relationship.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">has</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:profile</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Profile</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">belongs_to</span> <span class="ss">:person</span>
<span class="k">end</span>

<span class="c1"># Assigning a resource to a one-to-one relationship</span>

<span class="n">person</span>  <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">create</span>
<span class="n">person</span><span class="p">.</span><span class="nf">profile</span> <span class="o">=</span> <span class="no">Profile</span><span class="p">.</span><span class="nf">new</span>
<span class="n">person</span><span class="p">.</span><span class="nf">save</span>

<span class="c1"># Assigning a resource to a many-to-one relationship</span>

<span class="n">profile</span> <span class="o">=</span> <span class="no">Profile</span><span class="p">.</span><span class="nf">new</span>
<span class="n">profile</span><span class="p">.</span><span class="nf">person</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">create</span>
<span class="n">profile</span><span class="p">.</span><span class="nf">save</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Adding resources to any <em>one to many</em> or <em>many to many</em> relationship, can basically
be done in two different ways. If you don’t have the resource already, but only have
a hash of attributes, you can either call the <code class="highlighter-rouge">new</code> or the <code class="highlighter-rouge">create</code> method directly
on the association, passing it the attributes in form of a hash.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># find a post to add a comment to</span>

<span class="c1"># This will add a new but not yet saved comment to the collection</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:subject</span> <span class="o">=&gt;</span> <span class="s1">'DataMapper ...'</span><span class="p">)</span>

<span class="c1"># Both of the following calls will actually save the comment</span>
<span class="n">post</span><span class="p">.</span><span class="nf">save</span>     <span class="c1"># This will save the post along with the newly added comment</span>
<span class="n">comment</span><span class="p">.</span><span class="nf">save</span>  <span class="c1"># This will only save the comment</span>

<span class="c1"># This will create a comment, save it, and add it to the collection</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:subject</span> <span class="o">=&gt;</span> <span class="s1">'DataMapper ...'</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If you already have an existing <code class="highlighter-rouge">Comment</code> instance handy, you can just append that
to the association using the <code class="highlighter-rouge">&lt;&lt;</code> method. You still need to manually save the parent
resource to persist the comment as part of the related collection.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">post</span><span class="p">.</span><span class="nf">comments</span> <span class="o">&lt;&lt;</span> <span class="n">comment</span>  <span class="c1"># append an already existing comment</span>

<span class="c1"># Both of the following calls will actually save the comment</span>
<span class="n">post</span><span class="p">.</span><span class="nf">save</span>           <span class="c1"># This will save the post along with the newly added comment</span>
<span class="n">post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">save</span>  <span class="c1"># This will only save the comments collection</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>One important thing to know is that for related resources to know that they have
changed, you must change them via the API that the relationship (collection)
provides. If you cannot do this for whatever reason, you must call <code class="highlighter-rouge">reload</code> on the
model or collection in order to fetch the latest state from the storage backend.</p>

<p>The following example shows this behavior for a <em>one to many</em> relationship.
The same principle applies for all other kinds of relationships though.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>
  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>
  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:tasks</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Task</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>
  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>
  <span class="n">belongs_to</span> <span class="ss">:person</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we add a new task not by means of the API that the <code class="highlighter-rouge">tasks</code> collection
provides us, we must <code class="highlighter-rouge">reload</code> the collection in order to get the correct
results.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="n">ree</span><span class="o">-</span><span class="mf">1.8</span><span class="o">.</span><span class="mi">7</span><span class="o">-</span><span class="mf">2010.02</span> <span class="o">&gt;</span> <span class="nb">p</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">create</span>
 <span class="o">=&gt;</span> <span class="c1">#&lt;Person @id=1&gt;</span>
<span class="n">ree</span><span class="o">-</span><span class="mf">1.8</span><span class="o">.</span><span class="mi">7</span><span class="o">-</span><span class="mf">2010.02</span> <span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="no">Task</span><span class="p">.</span><span class="nf">create</span> <span class="ss">:person</span> <span class="o">=&gt;</span> <span class="nb">p</span>
 <span class="o">=&gt;</span> <span class="c1">#&lt;Task @id=1 @person_id=1&gt;</span>
<span class="n">ree</span><span class="o">-</span><span class="mf">1.8</span><span class="o">.</span><span class="mi">7</span><span class="o">-</span><span class="mf">2010.02</span> <span class="o">&gt;</span> <span class="nb">p</span><span class="p">.</span><span class="nf">tasks</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Task @id=1 @person_id=1&gt;]</span>
<span class="n">ree</span><span class="o">-</span><span class="mf">1.8</span><span class="o">.</span><span class="mi">7</span><span class="o">-</span><span class="mf">2010.02</span> <span class="o">&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="no">Task</span><span class="p">.</span><span class="nf">create</span> <span class="ss">:person</span> <span class="o">=&gt;</span> <span class="nb">p</span>
 <span class="o">=&gt;</span> <span class="c1">#&lt;Task @id=2 @person_id=1&gt;</span>
<span class="n">ree</span><span class="o">-</span><span class="mf">1.8</span><span class="o">.</span><span class="mi">7</span><span class="o">-</span><span class="mf">2010.02</span> <span class="o">&gt;</span> <span class="nb">p</span><span class="p">.</span><span class="nf">tasks</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Task @id=1 @person_id=1&gt;]</span>
<span class="n">ree</span><span class="o">-</span><span class="mf">1.8</span><span class="o">.</span><span class="mi">7</span><span class="o">-</span><span class="mf">2010.02</span> <span class="o">&gt;</span> <span class="nb">p</span><span class="p">.</span><span class="nf">tasks</span><span class="p">.</span><span class="nf">reload</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Task @id=1 @person_id=1&gt;, #&lt;Task @id=2 @person_id=1&gt;]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="customizing-associations">Customizing Associations</h2>

<p>The association declarations make certain assumptions about the names of foreign keys
and about which classes are being related. They do so based on some simple conventions.</p>

<p>The following two simple models will explain these default conventions in detail, showing
relationship definitions that solely rely on those conventions. Then the same relationship
definitions will be presented again, this time using all the available options explicitly.
These additional versions of the respective relationship definitions will have the exact same
effect as their simpler counterparts. They are only presented to show which options can be
used to customize various aspects when defining relationships.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Blog</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="c1"># The rules described below apply equally to definitions</span>
  <span class="c1"># of one-to-one relationships. The only difference being</span>
  <span class="c1"># that those would obviously only point to a single resource.</span>

  <span class="c1"># However, many-to-many relationships don't accept all the</span>
  <span class="c1"># options described below. They do support specifying the</span>
  <span class="c1"># target model, like we will see below, but they do not support</span>
  <span class="c1"># the :parent_key and the :child_key options. Instead, they</span>
  <span class="c1"># support another option that's available to many-to-many</span>
  <span class="c1"># relationships exclusively. This option is called :via, and</span>
  <span class="c1"># will be explained in more detail in its own paragraph below.</span>

  <span class="c1"># - This relationship points to multiple resources</span>
  <span class="c1"># - The target resources will be instances of the 'Post' model</span>
  <span class="c1"># - The local parent_key is assumed to be 'id'</span>
  <span class="c1"># - The remote child_key is assumed to be 'blog_id'</span>
  <span class="c1">#   - If the child model (Post) doesn't define the 'blog_id'</span>
  <span class="c1">#     child key property either explicitly, or implicitly by</span>
  <span class="c1">#     defining it using a belongs_to relationship, it will be</span>
  <span class="c1">#     established automatically, using the defaults described</span>
  <span class="c1">#     here ('blog_id').</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:posts</span>

  <span class="c1"># The following relationship definition has the exact same</span>
  <span class="c1"># effect as the version above. It's only here to show which</span>
  <span class="c1"># options control the default behavior outlined above.</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:posts</span><span class="p">,</span> <span class="s1">'Post'</span><span class="p">,</span>
    <span class="ss">:parent_key</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:id</span> <span class="p">],</span>      <span class="c1"># local to this model (Blog)</span>
    <span class="ss">:child_key</span>  <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:blog_id</span> <span class="p">]</span>  <span class="c1"># in the remote model (Post)</span>

<span class="k">end</span>

<span class="k">class</span> <span class="nc">Post</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="c1"># - This relationship points to a single resource</span>
  <span class="c1"># - The target resource will be an instance of the 'Blog' model</span>
  <span class="c1"># - The locally established child key will be named 'blog_id'</span>
  <span class="c1">#   - If a child key property named 'blog_id' is already defined</span>
  <span class="c1">#     for this model, then that will be used.</span>
  <span class="c1">#   - If no child key property named 'blog_id' is already defined</span>
  <span class="c1">#     for this model, then it gets defined automatically.</span>
  <span class="c1"># - The remote parent_key is assumed to be 'id'</span>
  <span class="c1">#   - The parent key must be (part of) the remote model's key</span>
  <span class="c1"># - The child key is required to be present</span>
  <span class="c1">#   - A parent resource must exist and be assigned, in order</span>
  <span class="c1">#     for this resource to be considered complete / valid</span>

  <span class="n">belongs_to</span> <span class="ss">:blog</span>

  <span class="c1"># The following relationship definition has the exact same</span>
  <span class="c1"># effect as the version above. It's only here to show which</span>
  <span class="c1"># options control the default behavior outlined above.</span>
  <span class="c1">#</span>
  <span class="c1"># When providing customized :parent_key and :child_key options,</span>
  <span class="c1"># it is not necessary to specify both :parent_key and :child_key</span>
  <span class="c1"># if only one of them differs from the default conventions.</span>
  <span class="c1">#</span>
  <span class="c1"># The :parent_key and :child_key options both accept arrays</span>
  <span class="c1"># of property name symbols. These should be the names of</span>
  <span class="c1"># properties being (at least part of) a key in either the</span>
  <span class="c1"># remote (:parent_key) or the local (:child_key) model.</span>
  <span class="c1">#</span>
  <span class="c1"># If the parent resource need not be present in order for this</span>
  <span class="c1"># model to be considered complete, :required =&gt; false can be</span>
  <span class="c1"># passed to stop DataMapper from establishing checks for the</span>
  <span class="c1"># presence of the attribute value.</span>

  <span class="n">belongs_to</span> <span class="ss">:blog</span><span class="p">,</span> <span class="s1">'Blog'</span><span class="p">,</span>
    <span class="ss">:parent_key</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:id</span> <span class="p">],</span>       <span class="c1"># in the remote model (Blog)</span>
    <span class="ss">:child_key</span>  <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:blog_id</span> <span class="p">],</span>  <span class="c1"># local to this model (Post)</span>
    <span class="ss">:required</span>   <span class="o">=&gt;</span> <span class="kp">true</span>           <span class="c1"># the blog_id must be present</span>

<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In addition to the <code class="highlighter-rouge">:parent_key</code> and <code class="highlighter-rouge">:child_key</code> options that we just saw,
the <code class="highlighter-rouge">belongs_to</code> method also accepts the <code class="highlighter-rouge">:key</code> option. If a <code class="highlighter-rouge">belongs_to</code>
relationship is marked with <code class="highlighter-rouge">:key =&gt; true</code>, it will either form the complete
primary key for that model, or it will be part of the primary key. The latter
will be the case if other properties or <code class="highlighter-rouge">belongs_to</code> definitions have been
marked with <code class="highlighter-rouge">:key =&gt; true</code> too, to form a composite primary key (<em>CPK</em>).
Marking a <code class="highlighter-rouge">belongs_to</code> relationship or any <code class="highlighter-rouge">property</code> with <code class="highlighter-rouge">:key =&gt; true</code>,
automatically makes it <code class="highlighter-rouge">:required =&gt; true</code> as well.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Post</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">belongs_to</span> <span class="ss">:blog</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>  <span class="c1"># 'blog_id' is the primary key</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="nb">id</span><span class="p">,</span> <span class="no">Serial</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Authorship</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">belongs_to</span> <span class="ss">:post</span><span class="p">,</span>   <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>  <span class="c1"># 'post_id'   is part of the CPK</span>
  <span class="n">belongs_to</span> <span class="ss">:person</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>  <span class="c1"># 'person_id' is part of the CPK</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When defining <em>many to many</em> relationships you may find that you need to
customize the relationship that is used to “go through”. This can be particularly
handy when defining self referential many-to-many relationships like we saw above.
In order to change the relationship used to “go through”, DataMapper allows us to
specifiy the <code class="highlighter-rouge">:via</code> option on <em>many to many</em> relationships.</p>

<p>The following example shows a scenario where we don’t use <code class="highlighter-rouge">:via</code> for defining
<em>self referential many to many</em> relationships. Instead, we will use <code class="highlighter-rouge">:via</code> to be
able to provide “better” names for use in our domain models.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Post</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:authorships</span>

  <span class="c1"># Without the use of :via here, DataMapper would</span>
  <span class="c1"># search for an :author relationship in Authorship.</span>
  <span class="c1"># Since there is no such relationship, that would</span>
  <span class="c1"># fail. By using :via =&gt; :person, we can instruct</span>
  <span class="c1"># DataMapper to use that relationship instead of</span>
  <span class="c1"># the :author default.</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:authors</span><span class="p">,</span> <span class="s1">'Person'</span><span class="p">,</span> <span class="ss">:through</span> <span class="o">=&gt;</span> <span class="ss">:authorships</span><span class="p">,</span> <span class="ss">:via</span> <span class="o">=&gt;</span> <span class="ss">:person</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="nb">id</span><span class="p">,</span> <span class="no">Serial</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Authorship</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">belongs_to</span> <span class="ss">:post</span><span class="p">,</span>   <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>  <span class="c1"># 'post_id'   is part of the CPK</span>
  <span class="n">belongs_to</span> <span class="ss">:person</span><span class="p">,</span> <span class="ss">:key</span> <span class="o">=&gt;</span> <span class="kp">true</span>  <span class="c1"># 'person_id' is part of the CPK</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="adding-conditions-to-associations">Adding Conditions to Associations</h2>

<p>If you want to order the association, or supply a scope, you can just pass in
the options…</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Post</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">has</span> <span class="n">n</span><span class="p">,</span> <span class="ss">:comments</span><span class="p">,</span> <span class="ss">:order</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:published_on</span><span class="p">.</span><span class="nf">desc</span> <span class="p">],</span> <span class="ss">:rating</span><span class="p">.</span><span class="nf">gte</span> <span class="o">=&gt;</span> <span class="mi">5</span>
  <span class="c1"># Post#comments will now be ordered by published_on, and filtered by rating &gt; 5.</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="finders-off-associations">Finders off Associations</h2>

<p>When you call an association off of a model, internally DataMapper creates a
Query object which it then executes when you start iterating or call <code class="highlighter-rouge">length</code>
off of. But if you instead call <code class="highlighter-rouge">.all</code> or <code class="highlighter-rouge">.first</code> off of the association and
provide it the exact same arguments as a regular <code class="highlighter-rouge">all</code> and <code class="highlighter-rouge">first</code>, it merges
the new query with the query from the association and hands you back a requested
subset of the association’s query results.</p>

<p>In a way, it acts like a database view in that respect.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="vi">@post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">first</span>
<span class="vi">@post</span><span class="p">.</span><span class="nf">comments</span>                                                    <span class="c1"># returns the full association</span>
<span class="vi">@post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="ss">:order</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:created_at</span><span class="p">.</span><span class="nf">desc</span> <span class="p">])</span>  <span class="c1"># return the first 10 comments, newest first</span>
<span class="vi">@post</span><span class="p">.</span><span class="nf">comments</span><span class="p">(</span><span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="ss">:order</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:created_at</span><span class="p">.</span><span class="nf">desc</span> <span class="p">])</span>      <span class="c1"># alias for #all, you can pass in the options directly</span>
<span class="vi">@post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">popular</span>                                            <span class="c1"># Uses the 'popular' finder method/scope to return only highly rated comments</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="querying-via-relationships">Querying via Relationships</h2>

<p>Sometimes it’s desirable to query based on relationships.  DataMapper makes this
as easy as passing a hash into the query conditions:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1"># find all Posts with a Comment by the user</span>
<span class="no">Post</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="ss">:comments</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:user</span> <span class="o">=&gt;</span> <span class="vi">@user</span> <span class="p">})</span>
<span class="c1"># in SQL =&gt; SELECT * FROM "posts" WHERE "id" IN</span>
<span class="c1">#     (SELECT "post_id" FROM "comments" WHERE "user_id" = 1)</span>

<span class="c1"># This also works (which you can use to build complex queries easily)</span>
<span class="no">Post</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="ss">:comments</span> <span class="o">=&gt;</span> <span class="no">Comment</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="ss">:user</span> <span class="o">=&gt;</span> <span class="vi">@user</span><span class="p">))</span>
<span class="c1"># in SQL =&gt; SELECT * FROM "posts" WHERE "id" IN</span>
<span class="c1">#     (SELECT "post_id" FROM "comments" WHERE "user_id" = 1)</span>

<span class="c1"># Of course, it works the other way, too</span>
<span class="c1"># find all Comments on posts with DataMapper in the title</span>
<span class="no">Comment</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="ss">:post</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:title</span><span class="p">.</span><span class="nf">like</span> <span class="o">=&gt;</span> <span class="s1">'%DataMapper%'</span> <span class="p">})</span>
<span class="c1"># in SQL =&gt; SELECT * from "comments" WHERE "post_id" IN</span>
<span class="c1">#     (SELECT "id" FROM "posts" WHERE "title" LIKE '%DataMapper%')</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>DataMapper accomplishes this (in sql data-stores, anyway) by turning the queries
across relationships into sub-queries.</p>


            <div id="footer">
        <p>Copyright Sam Smoot 2007, 2008</p>
        <p>Copyright Dan Kubb 2009-2012</p>
        <p>Web Design by <a href="http://www.mr-eel.com/">Luke Matthew Sutton</a> - Community Maintained</p>
      </div>

    </div>
  </body>
</html>
